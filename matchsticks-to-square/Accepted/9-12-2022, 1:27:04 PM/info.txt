{"id":798250602,"lang":"python3","time":"1 week, 5 days","timestamp":1663014424,"status_display":"Accepted","runtime":"6381 ms","url":"/submissions/detail/798250602/","is_pending":"Not Pending","title":"Matchsticks to Square","memory":"27.8 MB","code":"class Solution:\n    def makesquare(self, nums):\n        # If there are no matchsticks, then we can't form any square.\n        if not nums:\n            return False\n\n        # Number of matchsticks\n        L = len(nums)\n\n        # Possible perimeter of our square\n        perimeter = sum(nums)\n\n        # Possible side of our square from the given matchsticks\n        possible_side =  perimeter // 4\n\n        # If the perimeter isn't equally divisible among 4 sides, return False.\n        if possible_side * 4 != perimeter:\n            return False\n\n        # Memoization cache for the dynamic programming solution.\n        memo = {}\n\n        # mask and the sides_done define the state of our recursion.\n        def recurse(mask, sides_done):\n\n            # This will calculate the total sum of matchsticks used till now using the bits of the mask.\n            total = 0\n            for i in range(L - 1, -1, -1):\n                if not (mask & (1 << i)):\n                    total += nums[L - 1 - i]\n\n            # If some of the matchsticks have been used and the sum is divisible by our square's side, then we increment the number of sides completed.\n            if total > 0 and total % possible_side == 0:\n                sides_done += 1\n\n            # If we were successfully able to form 3 sides, return True\n            if sides_done == 3:\n                return True\n\n            # If this recursion state has already been calculated, just return the stored value.\n            if (mask, sides_done) in memo:\n                return memo[(mask, sides_done)]\n\n            # Common variable to store answer from all possible further recursions from this step.\n            ans = False\n\n            # rem stores available space in the current side (incomplete).\n            c = int(total / possible_side)\n            rem = possible_side * (c + 1) - total\n\n            # Iterate over all the matchsticks\n            for i in range(L - 1, -1, -1):\n\n                # If the current one can fit in the remaining space of the side and it hasn't already been taken, then try it out\n                if nums[L - 1 - i] <= rem and mask&(1 << i):\n\n                    # If the recursion after considering this matchstick gives a True result, just break. No need to look any further.\n                    # mask ^ (1 << i) makes the i^th from the right, 0 making it unavailable in future recursions.\n                    if recurse(mask ^ (1 << i), sides_done):\n                        ans = True\n                        break\n            # cache the result for the current recursion state.            \n            memo[(mask, sides_done)] = ans\n            return ans\n\n        # recurse with the initial mask with all matchsticks available.\n        return recurse((1 << L) - 1, 0)","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"matchsticks-to-square"}