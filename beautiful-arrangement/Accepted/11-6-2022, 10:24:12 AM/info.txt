{"id":838201105,"lang":"python3","lang_name":"Python3","time":"3 months, 2 weeks","timestamp":1667759052,"status":10,"status_display":"Accepted","runtime":"2393 ms","url":"/submissions/detail/838201105/","is_pending":"Not Pending","title":"Beautiful Arrangement","memory":"13.9 MB","code":"# If you try to solve this question using brute force. You will end up having TLE (Reason: One should notice that there's some kind of recursion involved into it. )\n# Because it involve's recursion, this problem can be solved using DP, Backtracking, BFS and DFS. \n# I personally thought it would be easy to solve this question using DFS. \n\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        \n        #Create our array from the value of n, we are using 1 till n+1 \n        nums=[i for i in range(1,n+1)]\n        \n        #Count variable.\n        self.count=0\n        \n        def dfs(nums,i:int=1):\n            #base condition, we need to increase the count when we have come to an end\n            if i==n+1:\n                self.count+=1\n                return\n            \n            \n            #checking for the 2 conditions, and changing our array\n            \n            for j,val in enumerate(nums):\n                #what we are basically doing is we are trying to reduce the size of the array if a current value doesn't satisfy the condition\n                if not (val%i and i% val):\n                    dfs(nums[:j]+nums[j+1:],i+1)\n        \n        dfs(nums)\n        return self.count\n        ","compare_result":"111111111111111","title_slug":"beautiful-arrangement","has_notes":false}