{"id":836415860,"question_id":1035,"lang":"python3","lang_name":"Python3","time":"2 years, 4 months","timestamp":1667522952,"status":10,"status_display":"Accepted","runtime":"35 ms","url":"/submissions/detail/836415860/","is_pending":"Not Pending","title":"Cousins in Binary Tree","memory":"14 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n#There are 2 conditions that we need to take care of\n    #1. Same depth\n    #2. Different Parent\nclass Solution:\n    def __init__(self):\n        self.is_Cousins=False\n        self.recorded_depth=None\n        \n    def dfs(self,root,depth,x,y):\n        #Base Condition\n        if root is None:\n            return False\n        \n        #Making sure that we are not traversing more than the depth of the other cousin if we have already found the depth of one.\n        if self.recorded_depth and depth>self.recorded_depth:\n            return False\n        \n        #in case if we are at the same depth\n        # Checking for first conditio\n        if root.val==x or root.val==y:  #Using OR instead of AND because we have make this program run for 2 cousin's \n            \n            #Check if recored_depth is present for a condition so that we can now check for the other cousin \n            if self.recorded_depth is None:\n                self.recorded_depth=depth\n                \n            #If the above is not None and both the depth's are same return True\n            return self.recorded_depth==depth\n            #Checking for second condition start's here and in case if we don't find the cousin's we keep on recursively do the same thing\n        left=self.dfs(root.left,depth+1,x,y)\n        right=self.dfs(root.right,depth+1,x,y)\n        \n        if left and right and self.recorded_depth!=depth+1:\n            self.is_Cousins=True\n            \n        return left or right\n        \n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        self.dfs(root,0,x,y)\n        return self.is_Cousins","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"cousins-in-binary-tree","has_notes":false,"flag_type":1}